/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/

#ifndef OSG_TERMPLATEPRIMITIVEFUNCTOR
#define OSG_TERMPLATEPRIMITIVEFUNCTOR 1

#include <osg/TemplatePrimitiveIndexFunctor>

namespace osg {
    template<class T>
    struct PrimitiveIndicesCollector
    {

        PrimitiveIndicesCollector() :
            _vertexArrayPtr(0),
            _intersectFunctor(0)
        {
        }

        inline void operator () (unsigned int p0)
        {
            _intersectFunctor->operator()(_vertexArrayPtr[p0], false);
        }

        inline void operator () (unsigned int p0, unsigned int p1)
        {
            _intersectFunctor->operator()(_vertexArrayPtr[p0], _vertexArrayPtr[p1], false);
        }

        inline void operator () (unsigned int p0, unsigned int p1, unsigned int p2)
        {
            _intersectFunctor->operator()(_vertexArrayPtr[p0], _vertexArrayPtr[p1], _vertexArrayPtr[p2], false);
        }

        inline void operator () (unsigned int p0, unsigned int p1, unsigned int p2, unsigned int p3)
        {
            _intersectFunctor->operator()(_vertexArrayPtr[p0], _vertexArrayPtr[p1], _vertexArrayPtr[p2], _vertexArrayPtr[p3], false);
        }

        const Vec3* _vertexArrayPtr;
        T* _intersectFunctor;
    };


/** Provides access to the primitives that compose an \c osg::Drawable.
    *  <p>Notice that \c TemplatePrimitiveFunctor is a class template, and that it inherits
    *  from its template parameter \c T. This template parameter must implement
    *  <tt>operator()(const osg::Vec3 v1, const osg::Vec3 v2, const osg::Vec3
    *  v3, bool treatVertexDataAsTemporary)</tt>,
    *  <tt>operator()(const osg::Vec3 v1, const osg::Vec3 v2, bool
    *  treatVertexDataAsTemporary)</tt>, <tt>operator()(const osg::Vec3 v1,
    *  const osg::Vec3 v2, const osg::Vec3 v3, bool treatVertexDataAsTemporary)</tt>,
    *  and <tt>operator()(const osg::Vec3 v1, const osg::Vec3 v2, const osg::Vec3 v3,
    *  const osg::Vec3 v4, bool treatVertexDataAsTemporary)</tt> which will be called
    *  for the matching primitive when the functor is applied to a \c Drawable.
    *  Parameters \c v1, \c v2, \c v3, and \c v4 are the vertices of the primitive.
    *  The last parameter, \c treatVertexDataAsTemporary, indicates whether these
    *  vertices are coming from a "real" vertex array, or from a temporary vertex array,
    *  created by the \c TemplatePrimitiveFunctor from some other geometry representation.
    *  @see \c PrimitiveFunctor for general usage hints.
    */
template<class T>
class TemplatePrimitiveFunctor : public PrimitiveFunctor, public T
{
public:

    TemplatePrimitiveFunctor()
    {
        _vertexArraySize=0;
        _vertexArrayPtr=0;
        _deleteVertexArray = false;
        _collectIndices._intersectFunctor = static_cast<T*>(this);
    }
    virtual ~TemplatePrimitiveFunctor() {
        deAllocateVertexArray();
    }
    Vec3* allocateVertexArray(unsigned int count) {
        if (_deleteVertexArray && _vertexArrayPtr) delete[] _vertexArrayPtr;
        _vertexArraySize = count;
        Vec3* vp = new Vec3[count];
        if (!vp) _vertexArraySize = 0;
        _deleteVertexArray = true;
        _vertexArrayPtr = vp;
        _collectIndices._vertexArrayPtr = vp;
        return vp;
    }
    void deAllocateVertexArray() {
        if (_deleteVertexArray && _vertexArrayPtr) delete[] _vertexArrayPtr;
    }

    virtual void setVertexArray(unsigned int count, const Vec2* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) vp[i].set(vertices[i].x(), vertices[i].y(), 0.0f);
    }

    virtual void setVertexArray(unsigned int count,const Vec3* vertices)
    {
        _vertexArraySize = count;
        _vertexArrayPtr = vertices;
        _deleteVertexArray = false;
        _collectIndices._vertexArrayPtr = _vertexArrayPtr;
    }

    virtual void setVertexArray(unsigned int count, const Vec4* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) {
            vp[i].set(vertices[i].x(), vertices[i].y(), vertices[i].z());
            if (vertices[i].w() > 0.0f) {
                vp[i] /= vertices[i].w();
            } else {
                vp[i].normalize();
                vp[i] *= 65536.0f;// FLT_MAX;
            }
        }
    }

    virtual void setVertexArray(unsigned int count,const Vec2d* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) vp[i].set(vertices[i].x(), vertices[i].y(), 0.0f);
    }

    virtual void setVertexArray(unsigned int count,const Vec3d* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) vp[i] = vertices[i];
    }

    virtual void setVertexArray(unsigned int count,const Vec4d* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) {
            vp[i].set(vertices[i].x(), vertices[i].y(), vertices[i].z());
            float w = vertices[i].w();
            if (w > 0.0f) {
                vp[i] /= w;
            }
            else {
                vp[i].normalize();
                vp[i] *= 65536.0f;// FLT_MAX;
            }
        }
    }

    virtual void setVertexArray(unsigned int count, const Vec2h* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) vp[i].set(vertices[i].x(), vertices[i].y(), 0.0f);
    }

    virtual void setVertexArray(unsigned int count,const Vec3h* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) vp[i].set(vertices[i].x(), vertices[i].y(), vertices[i].z());
    }

    virtual void setVertexArray(unsigned int count, const Vec4h* vertices)
    {
        Vec3* vp = allocateVertexArray(count);
        for (unsigned int i = 0; i < count; ++i) {
            vp[i].set(vertices[i].x(), vertices[i].y(), vertices[i].z());
            float w = vertices[i].w();
            if (w > 0.0f) {
                vp[i] /= w;
            }
            else {
                vp[i].normalize();
                vp[i] *= 65536.0f;// FLT_MAX;
            }
        }
    }

    virtual bool vertexArrayValid()
    {
        return (_vertexArraySize != 0);
    }

    virtual void drawArrays(GLenum mode,GLint first,GLsizei count)
    {
        _collectIndices.drawArrays(mode, first, count);
    }

    virtual void drawElements(GLenum mode,GLsizei count,const GLubyte* indices)
    {
        _collectIndices.drawElements(mode, count, indices);
    }

    virtual void drawElements(GLenum mode,GLsizei count,const GLushort* indices)
    {
        _collectIndices.drawElements(mode, count, indices);
    }

    virtual void drawElements(GLenum mode,GLsizei count,const GLuint* indices)
    {
        _collectIndices.drawElements(mode, count, indices);
    }

protected:

    unsigned int        _vertexArraySize;
    const Vec3*         _vertexArrayPtr;
    bool _deleteVertexArray;
    osg::TemplatePrimitiveIndexFunctor<PrimitiveIndicesCollector<T>> _collectIndices;
};


}

#endif
